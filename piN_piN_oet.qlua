require "stdlib"


-- cvc  g0  g1  g2  g3 g5 id
-- qlua g3  g0  g1  g2 g5 gamma[0]


function prepare_seq2_propagator_oet (L, prop, phi_p, phi_0, pvec, gi2, gf2 )

  local px = (2 * math.pi * pvec[1]) / L[0]
  local py = (2 * math.pi * pvec[2]) / L[1]
  local pz = (2 * math.pi * pvec[3]) / L[2]
  local w = ( L:Real(L:pcoord(0)) * px +
              L:Real(L:pcoord(1)) * py +
              L:Real(L:pcoord(2)) * pz):expi()

  K = L:DiracPropagator()


  local xi_gamma = ( gamma{n=gi2} * gamma{mu=5} ) * ( phi_0 * ( gamma{mu=5} * gamma{n=gf2} ) )
   
  for icol = 0, 2 do
    for ispin = 0, 3 do

      local w0 = ( qcd.dot (xi_gamma[{c=0,d=0}], prop[{d=ispin,c=icol}]) * w ):sum( L:MultiSet( L[3], L:pcoord(3) ) )
      local w1 = ( qcd.dot (xi_gamma[{c=0,d=1}], prop[{d=ispin,c=icol}]) * w ):sum( L:MultiSet( L[3], L:pcoord(3) ) )
      local w2 = ( qcd.dot (xi_gamma[{c=0,d=2}], prop[{d=ispin,c=icol}]) * w ):sum( L:MultiSet( L[3], L:pcoord(3) ) )
      local w3 = ( qcd.dot (xi_gamma[{c=0,d=3}], prop[{d=ispin,c=icol}]) * w ):sum( L:MultiSet( L[3], L:pcoord(3) ) )

      local v = L:DiracFermion()
      for t = 0, L[3]-1 do
          L:Subset{ axis=3, position = t }:where(function()
          v:set( ( phi_p[0] * w0[t] + phi_p[1] * w1[t] + phi_p[2] * w2[t] + phi_p[3] * w3[t] ) )
        end)
      end

      K[{d=ispin,c=icol}] = v

    end
  end

  return K
end
-- contract


function contract_mxb_mxb_oet (L, prop, phi_p, phi_0, pi2, src_loc, sample, aff_out ) 

  -- boundary phase
  local boundary_phase = vector.complex(L[3])
  for it = 0, src_loc[3] - 1 do
    boundary_phase[it] = -1
  end
  for it = src_loc[3], L[3]-1 do
    boundary_phase[it] = 1
  end

  local Gamma1 = gamma{mu=3} * gamma{mu=1} * gamma{mu=5}
  local Gamma2 = Gamma1
  local Pp =  (1 + gamma{mu=3}) / 2

  for ipf2, pf2 in ipairs ( pf2_list ) do 

    local pfifi = prepare_seq2_propagator_oet (L, prop, phi_p, phi_0, pf2, 15, 15 )

    local a2 = Gamma1 * ( prop * Gamma2 )

    local a3 = qcd.quarkContract13 ( a2 , prop  )

    local Z1 = ( ( (Pp * pfifi ) * a3 ):spintrace() ):trace()

    local Z2 = ( (Pp * pfifi ):spintrace() * a3:spintrace() ):trace()

    local a3 = qcd.quarkContract13 ( a2 , pfifi  )

    local Z3 = ( ( (Pp * prop ) * a3 ):spintrace() ):trace()

    local Z4 = ( (Pp * prop ):spintrace() * a3:spintrace() ):trace()

    for ipf1, pf1 in ipairs( pf1_list ) do

      pi1 = { -( pf1[1] + pf2[1] + pi2[1] ),
              -( pf1[2] + pf2[2] + pi2[2] ),
              -( pf1[3] + pf2[3] + pi2[3] ) }

      local pi1x = pi1[1] * 2 * math.pi / L[0]
      local pi1y = pi1[2] * 2 * math.pi / L[1]
      local pi1z = pi1[3] * 2 * math.pi / L[2]

      local pf1x = (2 * math.pi * pf1[1]) / L[0]
      local pf1y = (2 * math.pi * pf1[2]) / L[1]
      local pf1z = (2 * math.pi * pf1[3]) / L[2]

      local w = ( (L:Real(L:pcoord(0)) * pf1x + src_loc[0] * pi1x ) +
                  (L:Real(L:pcoord(1)) * pf1y + src_loc[1] * pi1y ) +
                  (L:Real(L:pcoord(2)) * pf1z + src_loc[2] * pi1z ) ):expi()


      local q2 = vector.complex( L[3] )
      local w2 = ((Z1+Z2+Z3+Z4) * w):sum(L:MultiSet(L[3], L:pcoord(3)))
      for i = 0, #w2 - 1 do
        it = ( i + src_loc[3] ) % L[3]
        q2[i] = -w2[it] * boundary_phase[it]
      end

      name = string.format("/pi1x%.2dpi1y%.2dpi1z%.2d/pi2x%.2dpi2y%.2dpi2z%.2d/pf1x%.2dpf1y%.2dpf1z%.2d/pf2x%.2dpf2y%.2dpf2z%.2d/x%.2dy%.2dz%.2dt%.2d/s%d",
          pi1[1], pi1[2], pi1[3],
          pi2[1], pi2[2], pi2[3],
          pf1[1], pf1[2], pf1[3],
          pf2[1], pf2[2], pf2[3],
          src_loc[0], src_loc[1], src_loc[2], src_loc[3], sample)
      aff_out:write(name, q2)

--      local q2 = vector.complex( L[3] )
--      local w2 = (Z2 * w):sum(L:MultiSet(L[3], L:pcoord(3)))
--      for i = 0, #w2 - 1 do
--        it = ( i + src_loc[3] ) % L[3]
--        q2[i] = -w2[it] * boundary_phase[it]
--      end
--
--      name = string.format("/Z2/pi1x%.2dpi1y%.2dpi1z%.2d/pi2x%.2dpi2y%.2dpi2z%.2d/pf1x%.2dpf1y%.2dpf1z%.2d/pf2x%.2dpf2y%.2dpf2z%.2d/x%.2dy%.2dz%.2dt%.2d/s%d",
--          pi1[1], pi1[2], pi1[3],
--          pi2[1], pi2[2], pi2[3],
--          pf1[1], pf1[2], pf1[3],
--          pf2[1], pf2[2], pf2[3],
--          src_loc[0], src_loc[1], src_loc[2], src_loc[3], sample)
--      aff_out:write(name, q2)
--
--      local q2 = vector.complex( L[3] )
--      local w2 = (Z3 * w):sum(L:MultiSet(L[3], L:pcoord(3)))
--      for i = 0, #w2 - 1 do
--        it = ( i + src_loc[3] ) % L[3]
--        q2[i] = -w2[it] * boundary_phase[it]
--      end
--
--      name = string.format("/Z3/pi1x%.2dpi1y%.2dpi1z%.2d/pi2x%.2dpi2y%.2dpi2z%.2d/pf1x%.2dpf1y%.2dpf1z%.2d/pf2x%.2dpf2y%.2dpf2z%.2d/x%.2dy%.2dz%.2dt%.2d/s%d",
--          pi1[1], pi1[2], pi1[3],
--          pi2[1], pi2[2], pi2[3],
--          pf1[1], pf1[2], pf1[3],
--          pf2[1], pf2[2], pf2[3],
--          src_loc[0], src_loc[1], src_loc[2], src_loc[3], sample)
--      aff_out:write(name, q2)
--
--      local q2 = vector.complex( L[3] )
--      local w2 = (Z4 * w):sum(L:MultiSet(L[3], L:pcoord(3)))
--      for i = 0, #w2 - 1 do
--        it = ( i + src_loc[3] ) % L[3]
--        q2[i] = -w2[it] * boundary_phase[it]
--      end
--
--      name = string.format("/Z4/pi1x%.2dpi1y%.2dpi1z%.2d/pi2x%.2dpi2y%.2dpi2z%.2d/pf1x%.2dpf1y%.2dpf1z%.2d/pf2x%.2dpf2y%.2dpf2z%.2d/x%.2dy%.2dz%.2dt%.2d/s%d",
--          pi1[1], pi1[2], pi1[3],
--          pi2[1], pi2[2], pi2[3],
--          pf1[1], pf1[2], pf1[3],
--          pf2[1], pf2[2], pf2[3],
--          src_loc[0], src_loc[1], src_loc[2], src_loc[3], sample)
--      aff_out:write(name, q2)

    end  -- of loop on total momenta momenta

  end

end
