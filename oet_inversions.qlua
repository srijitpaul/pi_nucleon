package.path = '/home/srijit/Dropbox/spaul/softwares/build2/parts/qlua/tree/lhpc/?.qlua;/home/srijit/Dropbox/spaul/softwares/build2/parts/qlua/tree/qlib/?.qlua;' .. package.path
--package.path = '/global/homes/s/srijitp/build/qlua_build_edison/build2/parts/qlua/tree/lhpc/?.qlua;/global/homes/s/srijitp/build/qlua_build_edison/build2/parts/qlua/tree/qlib/?.qlua;' .. package.path
require "stdlib"
require "gauge"
require "ape-smear"
require "wuppertal-smear"
require "stout-smear"
require "qdpc_io"
require "setup_util"
require "lhpc-std"
require "latvec"
require "hex-smear"
-- ************************************************************************************
-- * we use the following numbering
-- *
-- * N.M.X
-- *
-- * N in
-- * 1 --- M   -     M   2-point functions
-- * 2 --- MxM -     M   2-point functions
-- * 3 --- MxM -     MxM 2-point functions
-- * 4 --- M   - J - M   3-point functions
-- * 5 --- Mxm - J - M   3-point functions
-- *
-- * M in
-- * 1 --- light-light
-- * 2 --- light-charm
-- * 3 --- light-bottom
-- *
-- * X in
-- * a --- prepare eta_xi
-- * b --- prepare eta_phi
-- * c --- combine eta_xi and eta_phi
-- ************************************************************************************

-- ************************************************************************************
-- * INITIALIZE
-- ************************************************************************************

total_timer = timer("total time")

-- print parameters
printf("# [invert_contract_v3] Dimensions                = %d %d %d %d\n", dims[1], dims[2], dims[3], dims[4])
printf("# [invert_contract_v3] prefix to conf name       = %s\n", conf_name_prefix)
printf("# [invert_contract_v3] suffix to conf name       = %s\n", conf_name_input_suffix)
printf("# [invert_contract_v3] suffix to conf name       = %s\n", conf_name_output_suffix)
printf("# [invert_contract_v3] Clover Inverter\n")
printf("#\t light quark mass               = %g\n", mq_l)
printf("#\t light quark kappa              = %g\n", kappa_l)
printf("#\t strange quark mass               = %g\n", mq_s)
printf("#\t strange quark kappa              = %g\n", kappa_s)
printf("#\t Boundary condition = %d, %d, %d, %d\n", quark_bc[1], quark_bc[2], quark_bc[3], quark_bc[4])
-- TODO: what are relevant parameters for the multigrid solver?
-- printf("#\t Epsilon inner / final    = %e / %e\n", eps_i, eps_f)
-- printf("#\t Solver max. iters inner / total = %d\n", max_iter_i / dirac_max_iter)


    -- initialize the lattice
L = qcd.lattice(dims, {network=network_dims})

    Nd = #L

    volume = 1
    for i = 0, #L - 1 do
    volume = volume * L[i]
    end
    printf("# [invert_contract] lattice volume = %d\n", volume)

    -- initialize param set for writing propagators
    write_param = {
        ["m_q"]         = mq_l,
        ["c_sw"]        = csw,
        ["ferm_bc"]     = quark_bc,
        ["ensemble"]    = "beta3.31_2hex_24c48_ml-0.09530_mh-0.04",
        ["cfg"]         = nconf,
        ["ape_alpha"]   = ape_alpha,
        ["ape_n"]       = ape_n,
        ["ape_accu"]    = ape_accu,
        ["ape_maxiter"] = ape_maxiter,
        ["wup_alpha"]   = wup_alpha,
        ["wup_n"]       = wup_n,
        ["action_type"] = "clover",
        ["stout_rho"]   = stout_rho,
        ["stout_n"]     = stout_n,
        ["solver_eps"]  = mg_max_relerr,
        ["src_pos"]     = {-1, -1, -1},
        ["src_t"]       = -1
    }



if hex_smear then
-- read configuration
    conf_name = string.format("%s%04d%s", conf_name_prefix, nconf, conf_name_input_suffix)
    printf("# [invert_contract] reading original gauge configuration from file %s\n", conf_name)

    u_load_timer = timer("u load")
    uorig = load_nersc(L, conf_name)
    u_load_timer("done")
    printf("# [invert_contract] Plaquette (original) = %12.10f\n", plaquette_full(uorig))

    
    -- smear the gauge configuration
    hex_smear_timer = timer("hex smear")
    ubmw_hex = bmw_hex(uorig, 2)
    hex_smear_timer("done")
else
    -- read configuration
    conf_name = string.format("%s%04d%s", conf_name_prefix, nconf, conf_name_output_suffix)
    printf("# [invert_contract] reading hex-smeared gauge configuration from file %s\n", conf_name)

    os.exit(2)
end


-- APE-smear the configuration
if ape_n > 0 then
    ape_timer = timer("APE smearing")
    uape = APE_smear(ubmw_hex, ape_alpha, ape_n, ape_accu, ape_maxiter, ape_orthdir)
    ape_timer("done")
    printf("# [invert_contract] Plaquette after (light quark) APE smearing = %12.10f\n", plaquette_full(uape))
end
  
if not ( read_stochastic_source and read_forward_propagator and read_sequential_propagator and read_propagator_oet) then
    solver_light = make_mg_solver (L, ubmw_hex, mg_block, mg_max_abserr, mg_max_relerr, quark_bc, kappa_l, csw )
end

-- random number generator
S = random_state(L)

-- propagator lists
light_propagator_list = {}
light_propagator_smeared_list = {}
    --charm_propagator_list = {}
    --bottom_propagator_list = {}


light_sequential_propagator_list = {}


-- ************************************************************************************
-- * LOOP ON BASE SOURCE TIMESLICES
-- ************************************************************************************
for i_src, v_src in ipairs(source_locations) do

    local t   = v_src["t"]
    local pos = v_src["pos"]
    printf("# [invert_contract_v3] base source location[%d] = (%d, %d, %d) t=%d\n", i_src, pos[1], pos[2], pos[3], t)



    local i_prop = i_src
    printf("# [invert_contract_v3] setting forward propagator no. %d\n", i_prop)


    local source_timeslice = t


    local source_position = vector.int(4)
    source_position[0] = pos[1]
    source_position[1] = pos[2]
    source_position[2] = pos[3]
    source_position[3] = t



-- ************************************************************************************
-- * INVERT POINT SOURCE
-- ************************************************************************************

-- set a point source and smear the source

    local source = L:DiracPropagator()

    if not read_forward_propagator then

        for icol  = 0, 2 do
            for ispin = 0, 3 do
                printf("# [invert_contract_v3] setting / smearing point source  %d / %d - (c=%2d, s=%2d)\n", i_src, i_prop, icol, ispin)
                local dv  = L:DiracFermion()
                dv[{pos[1], pos[2], pos[3], t, c=icol, d=ispin}] = complex(1, 0)
                if wup_n > 0 then
                    -- source smearing
                    source[{c=icol,d=ispin}] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
                else
                    source[{c=icol,d=ispin}] = dv
                end
            end
        end

        -- propagator
        local i_timer = timer("light forward inversion")
        light_propagator_list[i_prop] = solver_light(source)
        i_timer("done")

        -- write the propagator UNSMEARED
        if write_forward_propagator then
            write_param["name"]    = light_propfile_prefix
            write_param["src_pos"] = pos
            write_param["src_t"]   = t

            write_propagator_lime (light_propagator_list[i_prop], write_param)

        end

    else
        printf("# [invert_contract_v3] reading light forward propagator\n")
        write_param["name"]    = light_propfile_prefix
        write_param["path"]    = light_propfile_path
        write_param["src_pos"] = pos
        write_param["src_t"]   = t
        light_propagator_list[i_prop] = read_propagator_lime (L, write_param)
    end
    -- sink smearing of the light forward propagator                          
    light_propagator_smeared_list[i_prop] = {}
    local temp = L:DiracPropagator()
    if wup_n > 0 then 
        wup_smear = timer("wuppertal smearing")
        for icol  = 0, 2 do                                                     
            for ispin = 0, 3 do                                                     
                local dv = light_propagator_list[i_prop][{c=icol,d=ispin}]            
                temp[{c=icol, d=ispin}] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
            end                                                                     
        end                            
        wup_smear("done")
        light_propagator_smeared_list[i_prop] = temp
    else                                                                      
        light_propagator_smeared_list[i_prop]  = light_propagator_list[i_prop]               
    end 
    temp = nil
--    --************************************************************************************
--    --* CONTRACTIONS 
--    --************************************************************************************
--    printf("# [invert_contract_baryon] B - B contraction for source location[%d / %d] = (%d, %d, %d) t=%d\n", i_src, i_prop, 
--            source_position[0], source_position[1], source_position[2], source_position[3]) 
--  
--    local name = string.format("%s.%.4d.x%.2dy%.2dz%.2dt%.2d", "contract_baryon_2pt", nconf, pos[1],pos[2],pos[3], t)
--    printf("# [invert_contract_baryon] B - B 2pt output file %s\n", name)
--    aw_b_b_2pt, am = qcd.aff.Writer(name)
--    name = nil
--    local ctimer = timer("contract B-B")
--    contract_baryon_2pt(L, light_propagator_smeared_list[i_prop], source_position, sink_momentum_list, aw_b_b_2pt)
--    ctimer("done")
--  
--    aw_b_b_2pt:close()
--  
--   
--    -- ************************************************************************************
--    -- * INVERT SEQUENTIAL SOURCE
--    -- ************************************************************************************
--
--    light_sequential_propagator_list[i_src] = {}
--
--    for i_seq_mom, seq_mom in ipairs(sequential_source_momentum_list) do
--
--        local seq_source_mom_timer = timer("seq_source_mom")
--        printf("#[invert_contract]  sequential source momentum(%d) = (%d, %d, %d)\n", i_seq_mom, seq_mom[1], seq_mom[2], seq_mom[3])
--
--        local seq_source_mom = L:DiracPropagator()
--
--
--        if not read_sequential_propagator then
--
--            -- local field exp(i p x)
--            --   p = seq_mom sequential source momentum
--            --   x = sink of light propagator
--            local px = (2 * math.pi * seq_mom[1]) / L[0]
--            local py = (2 * math.pi * seq_mom[2]) / L[1]
--            local pz = (2 * math.pi * seq_mom[3]) / L[2]
--            local phase = ( (L:Real(L:pcoord(0)) - pos[1]) * px +
--                            (L:Real(L:pcoord(1)) - pos[2]) * py +
--                            (L:Real(L:pcoord(2)) - pos[3]) * pz):expi()
--
--            -- Dirac gamma matrix at sequential vertex, is always g5 (binary gamma id 15)
--            local seq_gamma = sequential_source_gamma["val"]
--
--            -- sequential source at t = propagator at t
--            printf("# [invert_contract] adding source timeslice %d to sequential source list from propagator number %d\n", t, i_prop)
--            L:Subset{axis=3, position = t}:where(function()
--                seq_source_mom:set( light_propagator_list[i_prop] )
--                end)
--            -- seq_source_mom <- J exp(i p x) g5 J seq_source_mom
--            for icol  = 0, 2 do
--                for ispin = 0, 3 do
--        
--
--                    if wup_n > 0 then
--                        printf("# [invert_contract_v2] smearing source + setting gamma x moentum + smearing source %d / %d - (c=%2d, s=%2d)\n", i_src, i_seq_mom, icol, ispin)
--                        local dv = seq_source_mom[{c=icol,d=ispin}]
--                        local dv2 = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
--                        dv = phase * ( seq_gamma * dv2 )
--                        seq_source_mom[{c=icol,d=ispin}] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
--                    else
--                        printf("# [invert_contract] setting gamma x momentum %d / %d - (c=%2d, s=%2d)\n", i_src, i_seq_mom, icol, ispin)
--                        seq_source_mom[{c=icol,d=ispin}] = phase * ( seq_gamma * seq_source_mom[{c=icol,d=ispin}] )
--
--
--                    end
--
--                end
--            end
--            seq_source_mom_timer("done")
--
--            -- invert on the sequential momentum source
--            local i_timer = timer("light sequential inversion")
--            light_sequential_propagator_list[i_src][i_seq_mom] = solver_light(seq_source_mom)
--            i_timer("done")
--
--            -- write sequential propagator to file
--            if write_sequential_propagator then
--                write_param["name"]    = seq_propfile_prefix
--                write_param["src_pos"] = pos
--                write_param["src_t"]   = t
--                write_param["mom"]     = seq_mom
--                write_propagator_lime (light_sequential_propagator_list[i_src][i_seq_mom], write_param)
--
--            end  -- of if write_sequential_propagator
--
--        else
--            printf("# [invert_contract] reading light sequential propagator\n")
--            write_param["name"]    = seq_propfile_prefix
--            write_param["path"]    = seq_propfile_path
--            write_param["src_pos"] = pos
--            write_param["src_t"]   = t
--            write_param["mom"]     = seq_mom
--            light_sequential_propagator_list[i_src][i_seq_mom] = read_propagator_lime (L, write_param)
--            -- printf("Sequential Propagator for momenta (%d, %d, %d) =  %12.10f \n", 
--                -- seq_mom[1], seq_mom[2], seq_mom[3], 
--                --  print(light_sequential_propagator_list[i_src][i_seq_mom]:spintrace():trace():real():norm2())
--        end
--
--
--
--

        --  sink smearing of sequential propagator
        --  can be smeared at this point, since for 2-point and 3-point functions we
        --  always use the sequential propagator smeared at source and sink
--        if wup_n > 0 then
--            for icol  = 0, 2 do
--                for ispin = 0, 3 do
--                    printf("# [invert_contract] smearing sequential propagator %d / %d - (c=%2d, s=%2d)\n", i_src, i_seq_mom, icol, ispin)
--                    local dv = light_sequential_propagator_list[i_src][i_seq_mom][{c=icol, d=ispin}]
--                    light_sequential_propagator_list[i_src][i_seq_mom][{c=icol, d=ispin}] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
--                end
--            end
--              
--        end
--        
--        seq_source_mom = nil
--
--    end  -- end of loop on sequential source momenta

    --************************************************************************************
    --* CONTRACTIONS 
    --************************************************************************************
--    printf("# [invert_contract_baryon] B - B/B - M - B contraction for source location[%d / %d] = (%d, %d, %d) t=%d\n", i_src, i_prop, 
--            source_position[0], source_position[1], source_position[2], source_position[3]) 
--  
--    local name = string.format("%s.%.4d.x%.2dy%.2dz%.2dt%.2d", "contract_meson_baryon_2pt", nconf, pos[1],pos[2],pos[3], t)
--    printf("# [invert_contract_baryon] B - M - B 3pt output file %s\n", name)
--    aw_b_m_b_3pt, am = qcd.aff.Writer(name)
--    name = nil
--    local ctimer = timer("contract B-M-B")
--    for i_seq_mom, seq_mom in ipairs(sequential_source_momentum_list) do
--        printf("# [invert_contract] contract B-M-B for sequential source momentum(%d) = (%d, %d, %d)\n", i_seq_mom, seq_mom[1], seq_mom[2], seq_mom[3])
--        -- (2) light B-M-B - M 3-point function
--        contract_meson_baryon_3pt(L, light_sequential_propagator_list[i_src][i_seq_mom], light_propagator_smeared_list[i_prop], 
--                                  source_position, sink_momentum_list, seq_mom,  aw_b_m_b_3pt)
--    end
--    ctimer("done")
--    
--    aw_b_m_b_3pt:close()
  
  
end  -- of loop on base source locations

-- ****************************************************************************
-- * INVERSION FOR OET STOCHASTIC TIMESLICES SOURCES WITH ONE-END TRICK          *
-- ****************************************************************************
 
for i_src, v_src in ipairs(source_locations) do
    local t = v_src["t"]
    local pos = v_src["pos"]
    local i_prop = i_src
    
    local source_position = vector.int(4)
    source_position[0] = pos[1]
    source_position[1] = pos[2]
    source_position[2] = pos[3]
    source_position[3] = t
   
    -- open output files                                                          
    local name = string.format("%s.%.4d.x%.2dy%.2dz%.2dt%.2d.aff", "kontract_oet_pinpin_2pt", nconf,pos[1], pos[2], pos[3], t) 
    printf("# [] M - M 2pt output file %s\n", name)                               
    aw_2pt, am = qcd.aff.Writer(name)  

    oet_timer = timer("stochastic oet contraction timer")
    for i_sample = 0, nsample_oet - 1 do


        local light_stochastic_oet_source = Z2_SpinComponent_DiracFermion(S, 0)
        
        local light_stochastic_propagator_oet_list = {}
     
        local light_stochastic_propagator_oet_list_smeared = {}
        local phi_0 = L:DiracPropagator()
        for i_mom, mom in ipairs(pi2_list) do
            
        
        
            if not read_propagator_oet then
                
                printf("# [invert_contract_oet] momentum(%d) = (%d,%d, %d)\n", i_mom, mom[1], mom[2], mom[3])
        
                local px = (2 * math.pi * mom[1]) / L[0]
                local py = (2 * math.pi * mom[2]) / L[1]
                local pz = (2 * math.pi * mom[3]) / L[2]
        

                local phase = ( (L:Real(L:pcoord(0)) ) * px +
                                (L:Real(L:pcoord(1)) ) * py +
                                (L:Real(L:pcoord(2)) ) * pz):expi()
        
                local dv = L:DiracFermion()
        
                --selcet stochastic source timeslice t from volume souce, multiply with phase
                L:Subset{axis=3, position = t}:where(
                        function()
                        dv:set( phase * light_stochastic_oet_source )
                        end)
                
                momentum_source = dv
                --momentum_source = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)

                for kspin = 0, 3 do

                    light_stochastic_propagator_oet_list[kspin] = {}
                    printf("# [invert_contract_oet] spin component %d\n", kspin)

                    local dv = L:DiracFermion()
                    dv[{d= kspin}] = momentum_source[{d=0}]

                    printf("# [invert_contract_oet] t = %d, spin component %d\n", t, kspin)

                    local i_timer = timer("invert")
                    light_stochastic_propagator_oet_list[kspin] = solver_light(dv)
                    i_timer("done")

                    dv = nil
                

                    if  write_stochastic_oet_propagator then
                        write_param["name"] = string.format("%s_oet", stochastic_propfile_prefix)
                        write_param["src_t"] = t
                        write_param["mom"] = mom
                        write_param["sample"] = i_sample
                        write_param["spin"] = kspin 
                        write_propagator_lime(light_stochastic_propagator_oet_list[kspin], write_param)
                    end
                end
            else
            -- read a stochastic source from disk
                printf("Reading stochastic propagator\n")
                for kspin = 0, 3 do
                    write_param["name"]     = string.format("%s_oet", stochastic_propfile_prefix)
                    write_param["path"]     = stochastic_sourcefile_path
                    write_param["src_t"]    = t
                    write_param["mom"]      = mom
                    write_param["spin"]     = kspin
                    write_param["sample"]   = i_sample 
                    light_stochastic_propagator_oet_list[kspin] = read_propagator_lime(L, write_param)
                end
            end
            
            if  wup_n > 0 then                                                         
                for kspin = 0, 3 do                                                     
                    local dv = light_stochastic_propagator_oet_list[kspin]                    
                    light_stochastic_propagator_oet_list_smeared[kspin] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3) 
                end                                                                     
            else                                                                      
                light_stochastic_propagator_oet_list_smeared = light_stochastic_propagator_oet_list 
            end


            if  i_mom == 1 then
                if  mom[1] == 0 and mom[2] == 0 and mom[3] == 0 then
                    printf("# [invert_contract_oet] setting zero momentum stochastic propagator\n")    
                    -- set phi_0 only on color component c = 0                            
                    phi_0[{c=0, d=0}] = light_stochastic_propagator_oet_list_smeared[0]       
                    phi_0[{c=0, d=1}] = light_stochastic_propagator_oet_list_smeared[1]       
                    phi_0[{c=0, d=2}] = light_stochastic_propagator_oet_list_smeared[2]       
                    phi_0[{c=0, d=3}] = light_stochastic_propagator_oet_list_smeared[3] 

                else
                    printf("[invert_contract_oet] Error, first momentum should be zero momentum\n")
                    os.exit(2)
                end
            end
            contract_mxb_mxb_oet (L, light_propagator_smeared_list[i_prop], light_stochastic_propagator_oet_list_smeared, phi_0, mom,
                                 source_position, i_sample, aw_2pt )
        end
    end
    aw_2pt:close()
    oet_timer("done")
end
total_timer("done")
