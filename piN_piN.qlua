require "stdlib"

-- cvc  g0  g1  g2  g3 g5 id
-- qlua g3  g0  g1  g2 g5 gamma[0]
--QLUA BINARY GAMMA INDEX CONVENTION
-- Dirac_index      Binary Index
--  g0 * g2          -g10
--  g0                g08
--  g5                g15
--  g5 * g0           g07
--  g1 * g0           g09
--  g2 * g0           g10
--  g3 * g0           g12
--  g1                g01
--  g2                g02
--  g3                g04
--  Id                g00 


function contract_mbmb(prop, two_stoch_prop, oneseq_prop, one_stoch_prop, inp, out)

  local Cgin = -1 * gamma{n=10} * gamma{n=inp}
  local Cgout = -1 * gamma{n=10} * gamma{n=out} 
  local a2 = prop
  local a3 = qcd.quarkContract13(Cg5 * two_stoch_prop[i_pf2][i_pi2] * Cg5, prop )
  local a4 = qcd.quarkContract13( oneseq_prop[i_pi2] * Cg5, Cg5 * one_stoch_prop[i_pf2] )
  local res = a2*((a3 + a4):spintrace()) + (a2 *( a3 + a4 ))
  --local res = a2 *(a4)

  a4 = Pp * oneseq_prop[i_pi2] * Cg5
  a3 = qcd.quarkContract13( Cg5 * one_stoch_prop[i_pf2], prop )
  res = res + a4 * (a3 + (a3:spintranspose()))
  corr_proj = {}
  
  for i = 0, 15 do
    local Pp = gamma{n=i}
    corr_proj[i] = (Pp * res):spintrace():trace()
  end
  return corr_proj
end

function contract_meson_baryon_meson_baryon_2pt(L, prop, src_loc, oneseq_prop, xi, phi, aff_out)


  --boundary phase
  boundary_phase = vector.complex(L[3])
  for it = 0, src_loc[3] - 1 do
    boundary_phase[it] = -1
  end
  for it = src_loc[3], L[3]-1 do
    boundary_phase[it] = 1
  end


  -- *********************************************************************************

  local eta_xi = {}
  local w_eta_xi = {}
  w_timer = timer("w_eta_xi")
  c_timer = timer("mxm_mxm_2pt eta_xi")
  for i_pf2, pf2 in ipairs(pf2_list) do
    eta_xi[i_pf2] = {}
    w_eta_xi[i_pf2] = {}
    local px = (2 * math.pi * pf2[1]) / L[0]
    local py = (2 * math.pi * pf2[2]) / L[1]
    local pz = (2 * math.pi * pf2[3]) / L[2]

    local phase = ( L:Real(L:pcoord(0)) * px 
                  + L:Real(L:pcoord(1)) * py 
                  + L:Real(L:pcoord(2)) * pz)
                  :expi() 
    for icol = 0, 2 do
      w_eta_xi[i_pf2][icol] = {}

      for ispin = 0, 3 do
        local c  = qcd.dot( gamma{n=15} * xi, phase * (prop[{c=icol, d=ispin}]) )
        w_eta_xi[i_pf2][icol][ispin] = c:sum(L:MultiSet(L[3], L:pcoord(3)))                    
      end  -- end of loop on icol
    end  -- end of loop on ispin
     


    for i_pi2, pi2 in ipairs(pi2_list) do

      eta_xi[i_pf2][i_pi2] = {}
      for icol = 0, 2 do
        eta_xi[i_pf2][i_pi2][icol] = {}

        for ispin = 0, 3 do
                
          local c  = qcd.dot( gamma{mu=5} * xi, ( oneseq_prop[i_pi2][{c=icol, d=ispin}])*phase )
          eta_xi[i_pf2][i_pi2][icol][ispin] = c:sum(L:MultiSet(L[3], L:pcoord(3)))                    
        end  -- end of loop on icol
      end  -- end of loop on ispin
     
    end
  end  -- end of loop on pf2 list
  w_timer("done")
  c_timer("done")
      


      
  -- *********************************************************************************
  --combotimer = timer("mxm_mxm_2pt f1_f2_combination")
  local two_stoch_prop = {}
  local one_stoch_prop = {}
   
    
    
  for i_pf2, pf2 in ipairs(pf2_list) do

    two_stoch_prop[i_pf2] = {}
    one_stoch_prop[i_pf2] = {}
    --combotimer("done")
    
  
    local one_stoch = L:DiracPropagator()
    for icol = 0, 2 do                                                       
      for ispin = 0, 3 do
        local temp1 = L:DiracFermion()

        for it = 0, dt_source_sink_2pt do                                               
          L:Subset{axis=3, position=it}:where(function()
                  temp1:set(phi * w_eta_xi[i_pf2][icol][ispin][it])
                  end)
        end
        one_stoch[{c=icol, d=ispin}] = temp1           
            
      end
    end
    one_stoch_prop[i_pf2] = one_stoch


    for i_pi2, pi2 in ipairs(pi2_list) do
    --          g0            g2            g5

    local stoch = L:DiracPropagator()
      for icol = 0, 2 do                                                       
        for ispin = 0, 3 do
          local temp = L:DiracFermion()

          for it = 0, dt_source_sink_2pt do                                               
    
            L:Subset{axis=3, position=it}:where(function()
              temp:set(phi * eta_xi[i_pf2][i_pi2][icol][ispin][it])
              end)
          end
          stoch[{c=icol, d=ispin}] = temp
          --printf(" The norm of the Dirac Fermion with spin %d and color %d = %g\n",ispin, icol, stoch[{c=icol, d=ispin}]:norm2())            
        end
      end
      two_stoch_prop[i_pf2][i_pi2] = stoch
      local proton_gamma_index = {15, 0, 7, 8}
      for input_gamma in proton_gamma_index do
        for output_gamma in proton_gamma_index do
          
          piNpiN2pt_fw = contract_mbmb(prop, two_stoch_prop[i_pf2][i_pi2], oneseq_prop[i_pi2], one_stoch_prop[i_pf2], input_gamma, output_gamma)
          for i_pf1, pf1 in ipairs(pf1_list) do
  

            pi1 = { -( pf1[1] + pf2[1] + pi2[1] ),                                    
                    -( pf1[2] + pf2[2] + pi2[2] ),                                    
                    -( pf1[3] + pf2[3] + pi2[3] ) }




            local pi1x = (2 * math.pi * pi1[1]) / L[0]
            local pi1y = (2 * math.pi * pi1[2]) / L[1]
            local pi1z = (2 * math.pi * pi1[3]) / L[2]

            local pf1x = (2 * math.pi * pf1[1]) / L[0]
            local pf1y = (2 * math.pi * pf1[2]) / L[1]
            local pf1z = (2 * math.pi * pf1[3]) / L[2]

            local w = ( (L:Real(L:pcoord(0)) * pf1x + src_loc[0] * pi1x ) +           
                      (L:Real(L:pcoord(1)) * pf1y + src_loc[1] * pi1y ) +           
                      (L:Real(L:pcoord(2)) * pf1z + src_loc[2] * pi1z ) ):expi()
            
            for index = 0, 15 do
              local w2 = (piNpiN2pt_fw[index] * w):sum(L:MultiSet(L[3], L:pcoord(3)))    
              local q2 = vector.complex(L[3])

              for i = 0, #w2 - 1 do                       -- print 2pt values
                it = ( i + src_loc[3] ) % L[3]
                q2[i] = -w2[it] * boundary_phase[it]
              end

              name = string.format(
                    "/piNpiN/fw/proj%.2d/in%.2dout%.2d/pi2x%.2dpi2y%.2dpi2z%.2d/pf1x%.2dpf1y%.2dpf1z%.2d/pf2x%.2dpf2y%.2dpf2z%.2d/x%.2dy%.2dz%.2dt%.2d",
                    index, input_gamma, output_gamma, pi2[1], pi2[2], pi2[3], pf1[1], pf1[2], pf1[3],
                    pf2[1], pf2[2], pf2[3], src_loc[0], src_loc[1], src_loc[2],src_loc[3])
              aff_out:write(name, q2)
              w2=nil
              q2=nil
            end --projection loop
          end -- output_gamma
        end -- input_gamma
      end  -- of loop on snk_momenta
    end
  end


  boundary_phase = nil
end

