-- **************************************************************************
-- * invert_contract_oet_v2.qlua
-- *   
-- **************************************************************************

require "stdlib"
require "gauge"
require "ape-smear"
require "wuppertal-smear"

-- ************************************************************************************
-- * INITIALIZE
-- ************************************************************************************

-- start timer for total time
tot_timer = timer("total")

printf("# [invert_contract_oet_v2] Dimensions                = %d %d %d %d\n", dims[1], dims[2], dims[3], dims[4])
printf("# [invert_contract_oet_v2] prefix to conf name       = %s\n", conf_name_prefix)
printf("# [invert_contract_oet_v2] input suffix to conf name       = %s\n", conf_name_input_suffix)
printf("# [invert_contract_oet_v2] output suffix to conf name       = %s\n", conf_name_output_suffix)

printf("# [invert_contract_oet_v2] light propagator prefix         = %s\n", light_propfile_prefix)
--printf("# [invert_contract_oet_v2] charm propagator prefix         = %s\n", charm_propfile_prefix)
--printf("# [invert_contract_oet_v2] bottom propagator prefix         = %s\n", bottom_propfile_prefix)

printf("# [invert_contract_oet_v2] sequential propagator prefix         = %s\n", seq_propfile_prefix)

printf("# [invert_contract_oet_v2] stochastic propagator prefix         = %s\n", stochastic_propfile_prefix)
printf("# [invert_contract_oet_v2] stochastic source prefix         = %s\n", stochastic_sourcefile_prefix)

printf("# [invert_contract_oet_v2] Clover Inverter\n")
printf("#\t light quark mass               = %g\n", mq_l)
printf("#\t light quark kappa              = %g\n", kappa_l)
printf("#\t strange quark mass               = %g\n", mq_s)
printf("#\t strange quark kappa              = %g\n", kappa_s)
printf("#\t Boundary condition = %d, %d, %d, %d\n", quark_bc[1], quark_bc[2], quark_bc[3], quark_bc[4])
-- printf("#\t Epsilon inner / final    = %e / %e\n", eps_i, eps_f)
-- printf("#\t Solver max. iters inner / total = %d\n", max_iter_i / dirac_max_iter)


-- construct lattice
L = qcd.lattice(dims, {network=network_dims})

Nd = #L

volume = 1
for i = 0, #L - 1 do
  volume = volume * L[i]
end
printf("# [invert_contract_oet_v2] lattice volume = %d\n", volume)

-- initialize (info) parameters for writing propagators;
--   further parameters are set later one
write_param = {
  ["m_q"]         = mq_l,
  ["c_sw"]        = csw,
  ["ferm_bc"]     = quark_bc,
  ["ensemble"]    = "cl21_32_96_b6p1_m0p2850_m0p2450",
  ["cfg"]         = nconf,
  ["ape_alpha"]   = ape_alpha,
  ["ape_n"]       = ape_n,
  ["ape_accu"]    = ape_accu,
  ["ape_maxiter"] = ape_maxiter,
  ["wup_alpha"]   = wup_alpha,
  ["wup_n"]       = wup_n,
  ["action_type"] = "clover",
  ["stout_rho"]   = stout_rho,
  ["stout_n"]     = stout_n,
  ["solver_eps"]  = mg_max_relerr,
  ["src_pos"]     = {-1, -1, -1},
  ["src_t"]       = -1
}

-- load gauge configuration from file
if stout_smear then
  -- read configuration
  conf_name = string.format("%s%d%s", conf_name_prefix, nconf, conf_name_input_suffix)
  printf("# [invert_contract_oet_v2] reading original gauge configuration from file %s\n", conf_name)
    
  u_load_timer = timer("u load")
  uorig = load_nersc(L, conf_name)
  u_load_timer("done")
  printf("# [invert_contract_oet_v2] Plaquette (original) = %12.10f\n", plaquette_full(uorig))
    
  -- smear the gauge configuration
  stout_timer = timer("stout smear")
  printf("# [invert_contract_oet_v2] Stout-smearing gauge field\n")
  ustout = stout_smear_4d(uorig, stout_rho, stout_n)
  printf("# [invert_contract_oet_v2] Plaquette (smeared) = %12.10f\n", plaquette_full(ustout))
  stout_timer("done")
else
  -- read configuration
  conf_name = string.format("%s%d%s", conf_name_prefix, nconf, conf_name_output_suffix)
  printf("# [invert_contract_oet_v2] reading 4d-stout-smeared gauge configuration from file %s\n", conf_name)
    
  u_load_timer = timer("u load")
  ustout = load_ildg(L, conf_name)
  u_load_timer("done")
  printf("# [invert_contract_oet_v2] Plaquette (4d-stout-smeared) = %12.10f\n", plaquette_full(ustout))
end

--[[
-- TEST
ustout = {}
for i = 0, #L - 1 do
  ustout[i+1] = L:ColorMatrix(complex(1,0))
end
--]]

-- APE-smear the configuration
uape = APE_smear(ustout, ape_alpha, ape_n, ape_accu, ape_maxiter, ape_orthdir)
printf("# Plaquette after smearing = %12.10f\n", plaquette_full(uape))
 
-- constrcut the solver
solver_light = make_mg_solver (L, ustout, mg_block, mg_max_abserr, mg_max_relerr, quark_bc, kappa_l, csw )

-- TEST
--[[
function solver_light (v)
  L = v.lattice
  s = tostring(v)
  if string.find(s, "^QDP:DiracFermion") then
    dv = L:DiracFermion() 
  elseif string.find(s, "^QDP:DiracPropagator") then
    dv = L:DiracPropagator() 
  else
    printf("# [solver_light] Bad argument to solver: %s\n", s)
    os.exit(1)
  end
  dv:set(v)
  return dv
end
--]]

-- initialize lattice random state
S = random_state(L)


-- ***************************************************************************
-- * INVERSION FOR STOCHASTIC TIMESLICE SOURCES WITH ONE-END-TRICK
-- ***************************************************************************

local source_timer = timer("Z2xZ2 noise source")
-- construct a volume source with Z2 x Z2 noise in spin component 0
local light_stochastic_source = Z2_SpinComponent_DiracFermion(S,0)
source_timer("done")

if write_stochastic_source then
  write_param["name"]   = stochastic_sourcefile_prefix
  write_param["sample"] = 0
  write_propagator(light_stochastic_source, write_param)
end
 
-- loop on source locations
--   we only need the source timeslice for the stochastic timeslice sources

local i_sample = 0

for i_src, v_src in ipairs(source_locations) do

  local t   = v_src["t"]
  local pos = v_src["pos"]
  printf("# [invert_contract_oet_v2] current base source location[%d] = (%d, %d, %d) t=%d\n", i_src, pos[1], pos[2], pos[3], t)
 


    local i_prop = i_src

    local source_position = vector.int(4)
    source_position[0] = pos[1]
    source_position[1] = pos[2]
    source_position[2] = pos[3]
    source_position[3] = t

    local name = string.format("%s.%.4d.%.2d.%.5d", "Z_oet_eta_phi", nconf, t, i_sample)
    printf("# [invert_contract_oet] Z eta_phi output file %s\n", name)
    z_eta_phi, am = qcd.aff.Writer(name)

    name = string.format("%s.%.4d.%.2d.%.5d", "Z_oet_eta_phibar", nconf, t_coherent, i_sample)
    printf("# [invert_contract_oet] Z eta_phibar output file %s\n", name)
    z_eta_phibar, am = qcd.aff.Writer(name)

    -- name for output file of 2-point function contraction data
    name = string.format("%s.%.4d.t%.2d", "contract_m_m_oet_2pt", nconf, t_coherent)
    printf("# [invert_contract_oet] M - M 2pt stochastic (oet) output file %s\n", name)
    aw_m_m_stochastic, am = qcd.aff.Writer(name)
    name = nil

    local light_propagator = L:DiracPropagator()
    local light_propagator_smeared = L:DiracPropagator()

    if read_forward_propagator then
      printf("# [invert_contract_oet_v2] reading light forward propagator\n")
      write_param["name"]    = light_propfile_prefix
      write_param["path"]    = light_propfile_path
      write_param["src_pos"] = pos
      write_param["src_t"]   = t
      light_propagator = read_propagator (L, write_param)

    else
      printf("[invert_contract_oet] light forward propagators are required\n")
      os.exit(1)
    end

    --local light_propagator_deriv = gi_dcovi(ustout, light_propagator)

    if wup_n > 0 then
      for ispin = 0, 3 do
        for icol = 0, 2 do
          local dv = light_propagator[{c=icol, d=ispin}]
          light_propagator_smeared[{c=icol, d=ispin}] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
        end
      end
    else
      light_propagator_smeared = light_propagator
    end


    local phi_0 = L:DiracPropagator()
    local z_eta_phi = {}
    --local mxm_jd_m_cb_eta_phi = {}


    -- loop on momenta
    for i_mom, mom in ipairs(sequential_source_momentum_list) do

      printf("# [invert_contract_oet_v2] momentum(%d) = (%d, %d, %d)\n", i_mom, mom[1], mom[2], mom[3])

      local light_stochastic_propagator_list = {}
      local light_stochastic_propagator_list_smeared = {}

     -- local field exp(i p x)
      local px = (2 * math.pi * mom[1]) / L[0]
      local py = (2 * math.pi * mom[2]) / L[1]
      local pz = (2 * math.pi * mom[3]) / L[2]
      local phase = ( (L:Real(L:pcoord(0)) ) * px +
                      (L:Real(L:pcoord(1)) ) * py +
                      (L:Real(L:pcoord(2)) ) * pz):expi()
           
      local dv = L:DiracFermion()
      -- select stochastic source timeslice t from volume source, multiply with phase
      L:Subset{axis=3, position = t}:where(
        function()
          dv:set( phase * light_stochastic_source )
        end
      )
      --momentum_source = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
        momentum_source = dv
      for kspin = 0, 3 do
 
        printf("# [invert_contract_oet_v2] spin component %d\n", kspin)

        local dv = L:DiracFermion()
        dv[{d=kspin}] = momentum_source[{d=0}]
 
        printf("# [invert_contract_oet_v2] t = %d, spin component %d\n", t, kspin)

        -- invert
        local i_timer = timer("invert")
        light_stochastic_propagator_list[kspin] = solver_light(dv)
        i_timer("done")

        dv = nil
      end  -- end of loop on spin component


      if write_stochastic_propagator then
        write_param["name"] = string.format("%s_oet", stochastic_propfile_prefix)
        write_param["src_t"] = t_coherent
        write_param["mom"]   = mom
        write_propagator(light_stochastic_propagator_list, write_param) 
      end

      -- smear the stochastic timeslice propagator
      if wup_n > 0 then
        for kspin = 0, 3 do
          local dv = light_stochastic_propagator_list[kspin]
          light_stochastic_propagator_list_smeared[kspin] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
        end
      else
        light_stochastic_propagator_list_smeared = light_stochastic_propagator_list
      end
 

      if i_mom == 1 then
        if mom[1] == 0 and mom[2] == 0 and mom[3] == 0 then
          printf("# [invert_contract_oet_v2] setting zero momentum stochastic propagator\n")
  
          -- set phi_0 only on color component c = 0
          phi_0[{c=0, d=0}] = light_stochastic_propagator_list_smeared[0]
          phi_0[{c=0, d=1}] = light_stochastic_propagator_list_smeared[1]
          phi_0[{c=0, d=2}] = light_stochastic_propagator_list_smeared[2]
          phi_0[{c=0, d=3}] = light_stochastic_propagator_list_smeared[3]

          local tag = string.format("%s/pi2x%.2dpi2y%.2dpi2z%.2d", "z_eta_phi", mom[1], mom[2], mom[3])
          local c_timer = timer("contract light-light Z eta_phi")
          contract_z_eta_phi_write(L, light_propagator, light_stochastic_propagator_list, sink_momentum_list, aw_3pt_eta_phi, tag)
          c_timer("done")

        else
          printf("[invert_contract_oet_v2] Error, first momentum should be zero momentum\n")
          os.exit(2)
        end
      end

      -- ***************************************************************************
      -- * CONTRACTIONS
      -- *  for current source timeslice t and momentum mom
      -- ***************************************************************************

      local phi_p = L:DiracPropagator()
                            
      -- set phi_p only on color component c = 0
      phi_p[{c=0, d=0}] = light_stochastic_propagator_list_smeared[0]
      phi_p[{c=0, d=1}] = light_stochastic_propagator_list_smeared[1]
      phi_p[{c=0, d=2}] = light_stochastic_propagator_list_smeared[2]
      phi_p[{c=0, d=3}] = light_stochastic_propagator_list_smeared[3]
                            
      vector_gamma_index = {1,2,4,9,10,12,15}

      -- contraction
      local c_timer = timer("contract m-m 2pt stochastic")
      contract_vector_meson_2pt_stochastic(L, phi_0, phi_p, 0, t, sink_momentum_list, mom, aw_m_m_stochastic)
      c_timer("done")

      local tag = string.format("%s/pi2x%.2dpi2y%.2dpi2z%.2d", "z_eta_phibar", mom[1], mom[2], mom[3])

      c_timer = timer("contract light-light Z eta_phibar")
      contract_z_eta_phibar_write(L, light_propagator_smeared, light_stochastic_propagator_list_smeared, sink_momentum_list, z_eta_phibar, tag)
      c_timer("done")
 
      light_stochastic_propagator_list = nil
      light_stochastic_propagator_list_smeared = nil
      phi_p = nil
    end  -- end of loop on sink momentum list

    -- close the contraction output file
    z_eta_phi:close()
    z_eta_phibar:close()
    aw_m_m_stochastic:close()
--  end  -- end of loop on coherent sources

end  -- end of loop on source locations


tot_timer("done")
