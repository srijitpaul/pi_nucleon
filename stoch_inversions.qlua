--package.path = '/home/srijit/Dropbox/spaul/softwares/build2/parts/qlua/tree/lhpc/?.qlua;/home/srijit/Dropbox/spaul/softwares/build2/parts/qlua/tree/qlib/?.qlua;' .. package.path
package.path = '/global/homes/s/srijitp/build/qlua_build_edison/build2/parts/qlua/tree/lhpc/?.qlua;/global/homes/s/srijitp/build/qlua_build_edison/build2/parts/qlua/tree/qlib/?.qlua;' .. package.path
require "stdlib"
require "gauge"
require "ape-smear"
require "wuppertal-smear"
require "stout-smear"
require "qdpc_io"
require "setup_util"
require "lhpc-std"
require "latvec"

-- ************************************************************************************
-- * we use the following numbering
-- *
-- * N.M.X
-- *
-- * N in
-- * 1 --- M   -     M   2-point functions
-- * 2 --- MxM -     M   2-point functions
-- * 3 --- MxM -     MxM 2-point functions
-- * 4 --- M   - J - M   3-point functions
-- * 5 --- Mxm - J - M   3-point functions
-- *
-- * M in
-- * 1 --- light-light
-- * 2 --- light-charm
-- * 3 --- light-bottom
-- *
-- * X in
-- * a --- prepare eta_xi
-- * b --- prepare eta_phi
-- * c --- combine eta_xi and eta_phi
-- ************************************************************************************

-- ************************************************************************************
-- * INITIALIZE
-- ************************************************************************************

total_timer = timer("total time")

-- print parameters
printf("# [invert_contract_v3] Dimensions                = %d %d %d %d\n", dims[1], dims[2], dims[3], dims[4])
printf("# [invert_contract_v3] prefix to conf name       = %s\n", conf_name_prefix)
printf("# [invert_contract_v3] suffix to conf name       = %s\n", conf_name_input_suffix)
printf("# [invert_contract_v3] suffix to conf name       = %s\n", conf_name_output_suffix)
printf("# [invert_contract_v3] Clover Inverter\n")
printf("#\t light quark mass               = %g\n", mq_l)
printf("#\t light quark kappa              = %g\n", kappa_l)
printf("#\t strange quark mass               = %g\n", mq_s)
printf("#\t strange quark kappa              = %g\n", kappa_s)
printf("#\t Boundary condition = %d, %d, %d, %d\n", quark_bc[1], quark_bc[2], quark_bc[3], quark_bc[4])
-- TODO: what are relevant parameters for the multigrid solver?
-- printf("#\t Epsilon inner / final    = %e / %e\n", eps_i, eps_f)
-- printf("#\t Solver max. iters inner / total = %d\n", max_iter_i / dirac_max_iter)


    -- initialize the lattice
L = qcd.lattice(dims, {network=network_dims})

    Nd = #L

    volume = 1
    for i = 0, #L - 1 do
    volume = volume * L[i]
    end
    printf("# [invert_contract] lattice volume = %d\n", volume)

    -- initialize param set for writing propagators
    write_param = {
        ["m_q"]         = mq_l,
        ["c_sw"]        = csw,
        ["ferm_bc"]     = quark_bc,
        ["ensemble"]    = "beta3.31_2hex_24c48_ml-0.09530_mh-0.04",
        ["cfg"]         = nconf,
        ["ape_alpha"]   = ape_alpha,
        ["ape_n"]       = ape_n,
        ["ape_accu"]    = ape_accu,
        ["ape_maxiter"] = ape_maxiter,
        ["wup_alpha"]   = wup_alpha,
        ["wup_n"]       = wup_n,
        ["action_type"] = "clover",
        ["stout_rho"]   = stout_rho,
        ["stout_n"]     = stout_n,
        ["solver_eps"]  = mg_max_relerr,
        ["src_pos"]     = {-1, -1, -1},
        ["src_t"]       = -1
    }


if stout_smear then
-- read configuration
    conf_name = string.format("%s%04d%s", conf_name_prefix, nconf, conf_name_input_suffix)
    printf("# [invert_contract] reading original gauge configuration from file %s\n", conf_name)

    u_load_timer = timer("u load")
    uorig = load_nersc(L, conf_name)
    u_load_timer("done")
    printf("# [invert_contract] Plaquette (original) = %12.10f\n", plaquette_full(uorig))

    -- smear the gauge configuration
    stout_timer = timer("stout smear")
    printf("# [invert_contract] Stout-smearing gauge field\n")
    ustout = stout_smear_4d(uorig, stout_rho, stout_n)
    printf("# [invert_contract] Plaquette (smeared) = %12.10f\n", plaquette_full(ustout))
    stout_timer("done")
else
    -- read configuration
    conf_name = string.format("%s%d%s", conf_name_prefix, nconf, conf_name_output_suffix)
    printf("# [invert_contract] reading 4d-stout-smeared gauge configuration from file %s\n", conf_name)

    u_load_timer = timer("u load")
    ustout = load_ildg(L, conf_name)
    u_load_timer("done")
    printf("# [invert_contract] Plaquette (4d-stout-smeared) = %12.10f\n", plaquette_full(ustout))
    --printf("[invert_contract] Error, need original gauge configuration for heavy quark sector\n")
    os.exit(2)
end


-- APE-smear the configuration
if ape_n > 0 then
    ape_timer = timer("APE smearing")
    uape = APE_smear(ustout, ape_alpha, ape_n, ape_accu, ape_maxiter, ape_orthdir)
    ape_timer("done")
    printf("# [invert_contract] Plaquette after (light quark) APE smearing = %12.10f\n", plaquette_full(uape))
end
heavy_stout_timer = timer("heavy stout smear")
ustout_heavy = stout_smear_full(uorig, heavy_stout_rho, heavy_stout_n, 3)
heavy_stout_timer("done")
    -- TEST
    -- ustout_heavy = uorig
printf("# [invert_contract] Plaquette after (heavy quark) stout smearing = %12.10f\n", plaquette_full(ustout_heavy))


    -- TEST
if not ( read_stochastic_source and read_forward_propagator and read_sequential_propagator and read_propagator_oet) then
    solver_light = make_mg_solver (L, ustout, mg_block, mg_max_abserr, mg_max_relerr, quark_bc, kappa_l, csw )
end
--solver_heavy = make_aicl_solver(L, uorig, charm, bottom)


-- random number generator
S = random_state(L)

-- propagator lists
light_propagator_list = {}
light_propagator_smeared_list = {}
    --charm_propagator_list = {}
    --bottom_propagator_list = {}


light_sequential_propagator_list = {}


-- ************************************************************************************
-- * INVERT STOCHASTIC SOURCE
-- ************************************************************************************


local light_stochastic_propagator_list = {}
for i_sample = 0, nsample - 1 do

    --local charm_stochastic_propagator_list = {}
    --local bottom_stochastic_propagator_list = {}

    local light_stochastic_source = L:DiracFermion()
    local light_stochastic_propagator_smeared_allsink = L:DiracFermion()
    
    if not read_stochastic_source then
    -- make a Z2 x Z2 noise volume source
        light_stochastic_source = Z2_SpinComponent_DiracFermion(S, {0,1,2,3})
    
     

        if  write_stochastic_source then
            write_param["name"] = stochastic_sourcefile_prefix
            write_param["sample"] = i_sample
            write_propagator_lime(light_stochastic_source, write_param)
        end

    else
        -- read a stochastic source from disk
        printf("Reading stochastic source")
        write_param["name"] = stochastic_sourcefile_prefix
        write_param["path"] = stochastic_sourcefile_path
        write_param["sample"] = i_sample 
        light_stochastic_source = read_propagator_lime(L, write_param)

    end

    if not read_stochastic_propagator then

        light_stochastic_propagator_list[i_sample] = L:DiracFermion()
        printf("Writing stochastic propagator")
        for t = 0, L[3] - 1 do

            local source = L:DiracFermion()
            -- select stochastic source timeslice t from volume source
            L:Subset{axis=3, position=t}:where( function()
                source:set( light_stochastic_source )
                end)
        --end
            -- invert on the stochastic timeslice source
            -- light quark
            local v = L:DiracFermion()
            local inversion_time = timer("light stochastic propagator")
            v = solver_light(source)
            --light_stochastic_propagator_list[i_sample] = solver_light(source)
            inversion_time("done")
            L:Subset{axis=3, position=t}:where( function()
                light_stochastic_propagator_list[i_sample]:set( v )
                end)
            v = nil
            source = nil
        end

--    -- charm quark
--    inversion_time = timer("charm stochastic propagator")
--    charm_stochastic_propagator_list[i_stoch]  = solver_heavy(source, "charm")
--    inversion_time("done")
--
--    -- bottom quark
--    inversion_time = timer("bottom stochastic propagator")
--    bottom_stochastic_propagator_list[i_stoch] = solver_heavy(source, "bottom")
--    inversion_time("done")

        if write_stochastic_propagator then
            printf("Writing stochastic propagator")
            --write_param["src_t"]  = t
            write_param["sample"] = i_sample

            write_param["name"]   = string.format("%s_light", stochastic_propfile_prefix)
            write_propagator_lime(light_stochastic_propagator_list[i_sample], write_param)

    --    write_param["name"]   = string.format("%s_charm", stochastic_propfile_prefix)
    --write_propagator(charm_stochastic_propagator_list[i_stoch], write_param)
    --
    --    write_param["name"]   = string.format("%s_bottom", stochastic_propfile_prefix)
    --write_propagator(bottom_stochastic_propagator_list[i_stoch], write_param)

        end


    -- smear the stochastic timeslice propagator
    --   THE STOCHASTIC PROPAGATOR MUST NOT BE SMEARED AT THIS POINT, SINCE
    --   FOR THE CURRENT INSERTION WE NEED THE LOCAL PROPAGATOR SINK

    else
        printf("reading stochastic propagator for sample %d", i_sample)
        -- write_param["src_t"]  = t
        write_param["sample"] = i_sample
        write_param["path"]   = stochastic_propfile_path

        write_param["name"]   = string.format("%s_light", stochastic_propfile_prefix)
        -- TEST
        -- write_param["name"]   = string.format("%s", stochastic_propfile_prefix)
        light_stochastic_propagator_list[i_sample] = read_propagator_lime(L, write_param)
    end  -- of if not read_stochastic_propagator
end
---- ****************************************************************************
---- * INVERSION FOR OET STOCHASTIC TIMESLICES SOURCES WITH ONE-END TRICK          *
---- ****************************************************************************
-- 
--for i_src, v_src in ipairs(source_locations) do
--    local t = v_src["t"]
--    local pos = v_src["pos"]
--    local i_prop = i_src
--    
--    local source_position = vector.int(4)
--    source_position[0] = pos[1]
--    source_position[1] = pos[2]
--    source_position[2] = pos[3]
--    source_position[3] = t
--   
--    -- open output files                                                          
--    local name = string.format("%s.%.4d.tsrc%.2d.aff", "contract_baryon_2pt", nconf, t) 
--    printf("# [] M - M 2pt output file %s\n", name)                               
--    aw_2pt, am = qcd.aff.Writer(name)  
--
--    oet_timer = timer("stochastic oet contraction timer")
--    for i_sample = 0, nsample_oet - 1 do
--
--        --local light_stochastic_propagator_list = {}
--        --local charm_stochastic_propagator_list = {}
--        --local bottom_stochastic_propagator_list = {}
--
--        local light_stochastic_oet_source = Z2_SpinComponent_DiracFermion(S, 0)
--        
--        local light_stochastic_propagator_oet_list = {}
--     
--        local light_stochastic_propagator_oet_list_smeared = {}
--        local phi_0 = L:DiracPropagator()
--        for i_mom, mom in ipairs(pi2_list) do
--            
--        
--        
--            if not read_propagator_oet then
--                
--                printf("# [invert_contract_oet] momentum(%d) = (%d,%d, %d)\n", i_mom, mom[1], mom[2], mom[3])
--        
--                local px = (2 * math.pi * mom[1]) / L[0]
--                local py = (2 * math.pi * mom[2]) / L[1]
--                local pz = (2 * math.pi * mom[3]) / L[2]
--        
--
--                local phase = ( (L:Real(L:pcoord(0)) ) * px +
--                                (L:Real(L:pcoord(1)) ) * py +
--                                (L:Real(L:pcoord(2)) ) * pz):expi()
--        
--                local dv = L:DiracFermion()
--        
--                --selcet stochastic source timeslice t from volume souce, multiply with phase
--                L:Subset{axis=3, position = t}:where(
--                        function()
--                        dv:set( phase * light_stochastic_oet_source )
--                        end)
--                
--                momentum_source = dv
--                --momentum_source = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3)
--
--                for kspin = 0, 3 do
--
--                    light_stochastic_propagator_oet_list[kspin] = {}
--                    printf("# [invert_contract_oet] spin component %d\n", kspin)
--
--                    local dv = L:DiracFermion()
--                    dv[{d= kspin}] = momentum_source[{d=0}]
--
--                    printf("# [invert_contract_oet] t = %d, spin component %d\n", t, kspin)
--
--                    local i_timer = timer("invert")
--                    light_stochastic_propagator_oet_list[kspin] = solver_light(dv)
--                    i_timer("done")
--
--                    dv = nil
--                
--
--                    if  write_stochastic_oet_propagator then
--                        write_param["name"] = string.format("%s_oet", stochastic_propfile_prefix)
--                        write_param["src_t"] = t
--                        write_param["mom"] = mom
--                        write_param["sample"] = i_sample
--                        write_param["spin"] = kspin 
--                        write_propagator_lime(light_stochastic_propagator_oet_list[kspin], write_param)
--                    end
--                end
--            else
--            -- read a stochastic source from disk
--                printf("Reading stochastic propagator\n")
--                for kspin = 0, 3 do
--                    write_param["name"]     = string.format("%s_oet", stochastic_propfile_prefix)
--                    write_param["path"]     = stochastic_sourcefile_path
--                    write_param["src_t"]    = t
--                    write_param["mom"]      = mom
--                    write_param["spin"]     = kspin
--                    write_param["sample"]   = i_sample 
--                    light_stochastic_propagator_oet_list[kspin] = read_propagator_lime(L, write_param)
--                end
--            end
--            
--            if  wup_n > 0 then                                                         
--                for kspin = 0, 3 do                                                     
--                    local dv = light_stochastic_propagator_oet_list[kspin]                    
--                    light_stochastic_propagator_oet_list_smeared[kspin] = wuppertal_smear(uape, wup_alpha, wup_n, dv, 3) 
--                end                                                                     
--            else                                                                      
--                light_stochastic_propagator_oet_list_smeared = light_stochastic_propagator_oet_list 
--            end
--
--
--            if  i_mom == 1 then
--                if  mom[1] == 0 and mom[2] == 0 and mom[3] == 0 then
--                    printf("# [invert_contract_oet] setting zero momentum stochastic propagator\n")    
--                    -- set phi_0 only on color component c = 0                            
--                    phi_0[{c=0, d=0}] = light_stochastic_propagator_oet_list_smeared[0]       
--                    phi_0[{c=0, d=1}] = light_stochastic_propagator_oet_list_smeared[1]       
--                    phi_0[{c=0, d=2}] = light_stochastic_propagator_oet_list_smeared[2]       
--                    phi_0[{c=0, d=3}] = light_stochastic_propagator_oet_list_smeared[3] 
--
--                else
--                    printf("[invert_contract_oet] Error, first momentum should be zero momentum\n")
--                    os.exit(2)
--                end
--            end
--            contract_mxb_mxb_oet (L, light_propagator_list[i_prop], light_stochastic_propagator_oet_list_smeared, phi_0, mom,
--                                 source_position, i_sample, aw_2pt )
--    --    -- charm quark
--    --    inversion_time = timer("charm stochastic propagator")
--    --    charm_stochastic_propagator_list[i_stoch]  = solver_heavy(source, "charm")
--    --    inversion_time("done")
--    --
--    --    -- bottom quark
--    --    inversion_time = timer("bottom stochastic propagator")
--    --    bottom_stochastic_propagator_list[i_stoch] = solver_heavy(source, "bottom")
--    --    inversion_time("done")
--        end
--    end
--    oet_timer("done")
--end
total_timer("done")
