require "stdlib"

-- cvc  g0  g1  g2  g3 g5 id
-- qlua g3  g0  g1  g2 g5 gamma[0]

-- proton and antiproton

function proton_2pt(d, u, inp2, out2)

-----------------------------------------------------
--  Selection of the gamma index for N-N contractions
--  gammas can vary from 
--  CVC                 QLUA                              IN/OUT
--  identity          = gamma{n   = 0}                    1
--  gamma_5           = gamma{mu  = 5}                    5
--  gamma_0           = gamma{mu  = 3}                    3
--  gamma_0 * gamma_5 = gamma{mu  = 3}  * gamma{mu = 5}   6
----------------------------------------------------
  local gamma_in2
  if      inp2 == 6       then 
    gamma_in2 = gamma{mu=5} * gamma{mu=3}  
    gamma_in1 = gamma{n=0}  
  elseif  inp2 == 1       then
    gamma_in2 = gamma{n=0}
    gamma_in1 = gamma{mu=5}
  elseif  inp2 == 5       then
    gamma_in2 = gamma{mu=in2}
    gamma_in1 = gamma{n=0}
  else
    gamma_in2 = gamma{mu=in2}
    gamma_in1 = gamma{mu=5}
  end 


  local gamma_out2 
  if      out2 == 6       then
    gamma_out2 = gamma{mu=5} * gamma{mu=3}
    gamma_out1 = gammma{n=0}
  elseif  out2 == 1       then
    gamma_out2 = gamma{n=0}
    gamma_out1 = gamma{mu=5}
  elseif  out2 == 5       then
    gamma_out2 = gamma{mu=out2}
    gamma_out1 = gamma{n=0}
  else
    gamma_out2 = gamma{mu=out2}
    gamma_out1 = gamma{mu=5}
  end

  local Cgin  = gamma{mu=3} * gamma{mu=1} * gamma_in2
  local Cgout = gamma{mu=3} * gamma{mu=1} * gamma_out2
  local Pp =  (1 + gamma{mu=3}) / 2
  local a2 = Pp * gamma_out1 * gamma_in1 * u
  local a3 = qcd.quarkContract13(Cgout * d * Cgin, u )

  return (a2:spintrace() * a3:spintrace() + (a2 * a3):spintrace()):trace()
end


-- delta

function deltapp_2pt( u, inp, out)
  --          g0            g2            gmu 
  corr_proj = {}
  local Cgin = gamma{mu=3} * gamma{mu=1} * gamma{mu=inp}
  local Cgout = gamma{mu=3} * gamma{mu=1} * gamma{mu=out}
  --  local Pp =  (1 + gamma{mu=3}) / 4
  local bar_sign = vector.real(4)
  bar_sign[0] =  1  -- x
  bar_sign[1] = -1  -- y
  bar_sign[2] =  1  -- z
  bar_sign[3] =  1  -- t

  local a2 = u

  local a3 = qcd.quarkContract13( Cgout * u * Cgin, u )
  local a4 = qcd.quarkContract13( u * Cgin, Cgout * u )
  local res = a2*((a3 + a4):spintrace())  + (a2 *( a3 + a4 ))

  a4 = a2 * Cgin
  a3 = qcd.quarkContract13( Cgout * u, u )
  res = res + (a4 * (a3 + a3:spintranspose()))


  for i=0, 15 do

    local Pp =  gamma{n=i}
    corr_proj[i] = (( Pp * res ):spintrace():trace()) * bar_sign[out]
  end

  return corr_proj
end

--*********************************************************************
-- * run contractions
-- ********************************************************************
function contract_baryon_2pt(L, prop, src_loc, snk_momenta, aff_out)

  -- boundary phase
  boundary_phase = vector.complex(L[3])
  for it = 0, src_loc[3] - 1 do
    boundary_phase[it] = -1
  end
  for it = src_loc[3], L[3]-1 do
    boundary_phase[it] = 1
  end

  index = {1, 5, 3, 6}
  -- proton
  for input_gamma in index do
    for output_gamma in index do

      p2pt_fw = proton_2pt(prop, prop, input_gamma, output_gamma)

      for isnk, snk_mom in ipairs(snk_momenta) do
            
        local px = (2 * math.pi * snk_mom[1]) / L[0]
        local py = (2 * math.pi * snk_mom[2]) / L[1]
        local pz = (2 * math.pi * snk_mom[3]) / L[2]
        local w = ( (L:Real(L:pcoord(0)) - src_loc[0]) * px +
                    (L:Real(L:pcoord(1)) - src_loc[1]) * py +
                    (L:Real(L:pcoord(2)) - src_loc[2]) * pz):expi()
        local w2 = (p2pt_fw * w):sum(L:MultiSet(L[3], L:pcoord(3)))    
        local q2 = vector.complex(L[3])
        for i = 0, #w2 - 1 do                       -- print 2pt values
          it = ( i + src_loc[3] ) % L[3]
          q2[i] = w2[it] * boundary_phase[it]
                  
        end
        
        name = string.format("/proton/fw/in%.2d/out%.2d/px%.2dpy%.2dpz%.2d/x%.2dy%.2dz%.2dt%.2d",input_gamma, output_gamma,
                               snk_mom[1], snk_mom[2], snk_mom[3], src_loc[0], src_loc[1], src_loc[2],src_loc[3])
        aff_out:write(name, q2)
                         
            
        w2=nil
                  
        q2=nil
                
      end  -- of loop on snk_momenta
    end
  end
  
  -- delta 2-point
  for imu = 0, 3 do
    mu = (imu + 3) % 4
    for inu = 0, 3 do
      nu = (inu + 3) % 4

      dpp2pt_fw = deltapp_2pt(prop, mu, nu)


      for isnk, snk_mom in ipairs(snk_momenta) do
      
        local px = (2 * math.pi * snk_mom[1]) / L[0]
        local py = (2 * math.pi * snk_mom[2]) / L[1]
        local pz = (2 * math.pi * snk_mom[3]) / L[2]
        local w = ( (L:Real(L:pcoord(0)) - src_loc[0]) * px +
                    (L:Real(L:pcoord(1)) - src_loc[1]) * py +
                    (L:Real(L:pcoord(2)) - src_loc[2]) * pz):expi()
        for index = 0,15 do
          
          local w2 = (dpp2pt_fw[index] * w):sum(L:MultiSet(L[3], L:pcoord(3)))    

          local q2 = vector.complex(L[3])


          for i = 0, #w2 - 1 do                       -- print 2pt values
            it = ( i + src_loc[3] ) % L[3]
            q2[i] = w2[it] * boundary_phase[it]

                                    
          end

          name = string.format("/deltapp/fw/proj%.2d/in%dout%d/px%.2dpy%.2dpz%.2d/x%.2dy%.2dz%.2dt%.2d",
                                index, mu, nu,
                                snk_mom[1], snk_mom[2], snk_mom[3], src_loc[0], src_loc[1], src_loc[2],src_loc[3])
          aff_out:write(name, q2)

          w2=nil
          q2=nil
        end   -- of index of projectors
      end  -- of loop on snk_momenta
    end  -- of nu
  end  -- of mu

  boundary_phase = nil
end  -- contract_baryon_2pt
