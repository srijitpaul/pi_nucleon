require "stdlib"

-- cvc  g0  g1  g2  g3 g5 id
-- qlua g3  g0  g1  g2 g5 gamma[0]

--QLUA BINARY GAMMA INDEX CONVENTION
-- Dirac_index      Binary Index
--  g0 * g2          -g10
--  g0                g08
--  g5                g15
--  g5 * g0           g07
--  g1 * g0           g09
--  g2 * g0           g10
--  g3 * g0           g12
--  g1                g01
--  g2                g02
--  g3                g04
--  Id                g00 



-- proton and antiproton

function proton_2pt(d, u, inp1, out1)

  local inp2
  local out2
  if inp1 == 15 then
    inp2 = 0
  elseif inp1 == 0 then
    inp2 = 15 
  elseif inp1 == 7 then
    inp2 = 0
  elseif inp1 == 8 then
    inp2 = 15
  end


  if out1 == 15 then
    out2 = 0
  elseif out1 == 0 then
    out2 = 15 
  elseif out1 == 7 then
    out2 = 0
  elseif out1 == 8 then
    out2 = 15
  end



  local Cgin  = -1 * gamma{n=10} * gamma{n=inp1}
  local Cgout = -1 * gamma{n=10} * gamma{n=out1}  
  corr_proj = {}
  local a2    = gamma{n=out2} * gamma{n=inp2} * u
  local a3    = qcd.quarkContract13(Cgout * d * Cgin, u )
  local res   = (a2 * a3:spintrace()) + (a2 * a3)
  
--  for i=0, 15 do
--    local Pp =  gamma{n=i}
--    corr_proj[i] = (Pp * res): spintrace():trace()
--  end
--  return corr_proj
--Extracting each spin projection of the result dirac propagator
  local spin_proj = {}
  
  for ispin1 = 0, 3 do
    
    spin_proj[ispin1] = {}
    for ispin2 = 0, 3 do
        local dv = L:DiracFermion()
        local corr = L:Complex()
        for icol1 = 0, 2 do
                
            dv = res[{c=icol1, d=ispin2}]
            corr = corr + dv[{c=icol1, d=ispin1}]
            spin_proj[ispin1][ispin2]  =  corr

            
        end
        corr = nil
        dv = nil
     end
   end

  return spin_proj
end


-- delta

function deltapp_2pt( u, inp, out, out_index)
  --          g0            g2            gmu 
  corr_proj = {}
  local Cgin = -1 * gamma{n=10} * gamma{n=inp}
  local Cgout = -1 * gamma{n=10}* gamma{n=out}
  --  local Pp =  (1 + gamma{mu=3}) / 4
  local bar_sign = vector.real(4)
  bar_sign[0] =  1  -- x
  bar_sign[1] = -1  -- y
  bar_sign[2] =  1  -- z
  --bar_sign[3] =  1  -- t

  local a2 = u

  local a3 = qcd.quarkContract13( Cgout * u * Cgin, u )
  local a4 = qcd.quarkContract13( u * Cgin, Cgout * u )
  local res = a2*((a3 + a4):spintrace())  + (a2 *( a3 + a4 ))

  a4 = a2 * Cgin
  a3 = qcd.quarkContract13( Cgout * u, u )
  res = res + (a4 * (a3 + a3:spintranspose()))
--out_i = (out_index - 1)%3
--  for i=0, 15 do

--    local Pp =  gamma{n=i}
--    corr_proj[i] = (( Pp * res ):spintrace():trace()) * bar_sign[out_i]
--  end

--  return corr_proj
--Extracting each spin projection of the result dirac propagator
  local spin_proj = {}
  
  for ispin1 = 0, 3 do
    
    spin_proj[ispin1] = {}
    for ispin2 = 0, 3 do
        local dv = L:DiracFermion()
        local corr = L:Complex()
        for icol1 = 0, 2 do
                
            dv = res[{c=icol1, d=ispin2}]
            corr = corr + dv[{c=icol1, d=ispin1}]
            spin_proj[ispin1][ispin2]  =  corr

            
        end
        corr = nil
        dv = nil
     end
   end

  return spin_proj


end

--*********************************************************************
-- * run contractions
-- ********************************************************************
function contract_baryon_2pt(L, prop, src_loc, snk_momenta, aff_out)

  -- boundary phase
  boundary_phase = vector.complex(L[3])
  for it = 0, src_loc[3] - 1 do
    boundary_phase[it] = -1
  end
  for it = src_loc[3], L[3]-1 do
    boundary_phase[it] = 1
  end

  local proton_gamma_index = {15, 0, 7, 8}
  -- proton
  for input_gamma = 1, #proton_gamma_index do
    for output_gamma = 1, #proton_gamma_index do

      p2pt_fw = proton_2pt(prop, prop, proton_gamma_index[input_gamma], proton_gamma_index[output_gamma])

      for isnk, snk_mom in ipairs(snk_momenta) do
            
        local px = (2 * math.pi * snk_mom[1]) / L[0]
        local py = (2 * math.pi * snk_mom[2]) / L[1]
        local pz = (2 * math.pi * snk_mom[3]) / L[2]
        local w = ( (L:Real(L:pcoord(0)) - src_loc[0]) * px +
                    (L:Real(L:pcoord(1)) - src_loc[1]) * py +
                    (L:Real(L:pcoord(2)) - src_loc[2]) * pz):expi()

        for index1 = 0, 3 do

          for index2 = 0, 3 do
            local w2 = (p2pt_fw[index1][index2] * w):sum(L:MultiSet(L[3], L:pcoord(3)))    
            local q2 = vector.complex(L[3])
            for i = 0, #w2 - 1 do                       -- print 2pt values
              it = ( i + src_loc[3] ) % L[3]
              q2[i] = w2[it] * boundary_phase[it]
                      
            end
            
            name = string.format("/proton/fw/s1%.2d/s2%.2d/in%.2dout%.2d/px%.2dpy%.2dpz%.2d/x%.2dy%.2dz%.2dt%.2d", index1, 
                                  index2, proton_gamma_index[input_gamma], proton_gamma_index[output_gamma],
                                   snk_mom[1], snk_mom[2], snk_mom[3], src_loc[0], src_loc[1], src_loc[2],src_loc[3])
            aff_out:write(name, q2)
                             
                
            w2=nil
                      
            q2=nil
          end
        end        
      end  -- of loop on snk_momenta
    end
  end
  
  -- delta 2-point

  local delta_gamma_index = { 9, 10, 12, 1, 2, 4}
  for input_gamma = 1, #delta_gamma_index do
    for output_gamma = 1, #delta_gamma_index do

      dpp2pt_fw = deltapp_2pt(prop, delta_gamma_index[input_gamma], delta_gamma_index[output_gamma], output_gamma)


      for isnk, snk_mom in ipairs(snk_momenta) do
      
        local px = (2 * math.pi * snk_mom[1]) / L[0]
        local py = (2 * math.pi * snk_mom[2]) / L[1]
        local pz = (2 * math.pi * snk_mom[3]) / L[2]
        local w = ( (L:Real(L:pcoord(0)) - src_loc[0]) * px +
                    (L:Real(L:pcoord(1)) - src_loc[1]) * py +
                    (L:Real(L:pcoord(2)) - src_loc[2]) * pz):expi()
        for index1 = 0, 3 do
  
          for index2 = 0, 3 do
          
            local w2 = (dpp2pt_fw[index1][index2] * w):sum(L:MultiSet(L[3], L:pcoord(3)))    

            local q2 = vector.complex(L[3])


            for i = 0, #w2 - 1 do                       -- print 2pt values
              it = ( i + src_loc[3] ) % L[3]
              q2[i] = w2[it] * boundary_phase[it]

                                      
            end

            name = string.format("/deltapp/fw/s1%.2d/s2%.2d/in%dout%d/px%.2dpy%.2dpz%.2d/x%.2dy%.2dz%.2dt%.2d",
                                  index1, index2, delta_gamma_index[input_gamma], delta_gamma_index[output_gamma],
                                  snk_mom[1], snk_mom[2], snk_mom[3], src_loc[0], src_loc[1], src_loc[2],src_loc[3])
            aff_out:write(name, q2)

            w2=nil
            q2=nil
          end
        end   -- of index of projectors
      end  -- of loop on snk_momenta
    end  -- of nu
  end  -- of mu

  boundary_phase = nil
end  -- contract_baryon_2pt
--**************************************
--* pion  2-point function
--* - use point-to-all propagators
--**************************************

function pion_2pt_local(u1, u2)
  u3 = gamma{mu=5} * u2 * gamma{mu=5}

        qq = {}
        qq = qcd.dot(u3, gamma{mu=5} * u1 * gamma{mu=5})
  
  u3 = nil
  return(qq)
end

function pion2pt(qq_c, p3, nconf)
  local px = 2 * math.pi * p3[1] / L[0]
  local py = 2 * math.pi * p3[2] / L[1]
  local pz = 2 * math.pi * p3[3] / L[2]
  local w = (L:Real(L:pcoord(0)) * px +
             L:Real(L:pcoord(1)) * py +
             L:Real(L:pcoord(2)) * pz):expi()  -- plane wave with p=(px,py,pz)
  local pt2 = (qq_c * w):sum(L:MultiSet(L[3], L:pcoord(3)))  -- 2pt function
  momenta_save_directory = "Twop/pion/"
  momenta_format = "/px%dpy%dpz%d"
  directory_name = string.format("%s%s", momenta_save_directory, momenta_format)
  aw:write(string.format(directory_name, p3[1], p3[2], p3[3]),pt2)
  aw:close()
end


