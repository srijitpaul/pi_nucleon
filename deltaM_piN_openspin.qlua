require "stdlib"

-- cvc  g0  g1  g2  g3 g5 id
-- qlua g3  g0  g1  g2 g5 gamma[0]

--QLUA BINARY GAMMA INDEX CONVENTION
-- Dirac_index      Binary Index
--  g0 * g2          -g10
--  g0                g08
--  g5                g15
--  g5 * g0           g07
--  g1 * g0           g09
--  g2 * g0           g10
--  g3 * g0           g12
--  g1                g01
--  g2                g02
--  g3                g04
--  Id                g00 

-- delta-Meson--pi-Nucleon

function deltaMpiN_3pt(seq, u, inp, out, out_index)
  --          g0            g2            gmu 
  corr_proj = {}
  local Cgin = -1 * gamma{n=10} * gamma{n=inp} 
  local Cgout = -1 * gamma{n=10} * gamma{n=out}
  local bar_sign = vector.real(4)
  bar_sign[0] =  1  -- x
  bar_sign[1] = -1  -- y
  bar_sign[2] =  1  -- z
--  bar_sign[3] =  1  -- t

  local a2 = u 
--  printf("Sequential propagator norm: %12.10f\n",seq:spintrace():trace():real():norm2())
--  printf("Forward propagator norm:%12.10f\n", u:spintrace():trace():real():norm2())
  local a3 = qcd.quarkContract13( Cgout * seq * Cgin, u )
  local a4 = qcd.quarkContract13( seq * Cgin, Cgout * u )
  local res = a2 * (( a3 + a4 ):spintrace()) + (a2 * ( a3 + a4 ))

  a4 = seq * Cgin
  a3 = qcd.quarkContract13( Cgout * u, u )
  res = res + (a4 * (a3 + a3:spintranspose()))
  
--  out_i = (out_index - 1)%3
--  for i=0, 15 do
--
--    local Pp = gamma{n=i}
--    corr_proj[i] = ((Pp * res ):spintrace():trace()) * bar_sign[out_i]
--  end
--
--  return corr_proj

--Extracting each spin projection of the result dirac propagator
  local spin_proj = {}
  
  for ispin1 = 0, 3 do
    
    spin_proj[ispin1] = {}
    for ispin2 = 0, 3 do
        local dv = L:DiracFermion()
        local corr = L:Complex()
        for icol1 = 0, 2 do
                
            dv = res[{c=icol1, d=ispin2}]
            corr = corr + dv[{c=icol1, d=ispin1}]
            spin_proj[ispin1][ispin2]  =  corr

            
        end
        corr = nil
        dv = nil
     end
   end

  return spin_proj

end

-- ********************************************************************
-- * run contractions
-- ********************************************************************
function contract_meson_baryon_3pt(L, seq, prop, src_loc, snk_momenta, seq_mom,  aff_out)

  -- boundary phase
  boundary_phase = vector.complex(L[3])
  for it = 0, src_loc[3] - 1 do
    boundary_phase[it] = -1
  end
  for it = src_loc[3], L[3]-1 do
    boundary_phase[it] = 1
  end

  local proton_gamma_index = {15, 0, 7, 8}
  local delta_gamma_index = { 9, 10, 12, 1, 2, 4}
-- delta 2-point
  for input_gamma = 1, #proton_gamma_index do
    for output_gamma = 1, #delta_gamma_index do 
 

      dNpiN3pt_fw = deltaMpiN_3pt(seq, prop, proton_gamma_index[input_gamma], delta_gamma_index[output_gamma], output_gamma)



      dNpiN3pt_fw_index = {}
      for index1 = 0, 3 do

        for index2 = 0, 3 do
        
          name = string.format("/deltaMpiN/s1%.2d/s2%.2d/in%dout%d/pi2x%.2dpi2y%.2dpi2z%.2d",
                                index1, index2, proton_gamma_index[input_gamma], delta_gamma_index[output_gamma],
                                seq_mom[1], seq_mom[2], seq_mom[3])

          dNpiN3pt_fw_index[name] = dNpiN3pt_fw[index1][index2]

        end
      end   -- of index of projectors
      t_axis = #dims - 1
      src0 = {src_loc[0], src_loc[1], src_loc[2], src_loc[3]}
      qcd.save_momproj(aff_out, '', dNpiN3pt_fw_index, src0, snk_momenta, t_axis, 1, {ft_sign=1})
        
 
    end  -- of output_gamma
  end -- of input_gamma
  boundary_phase = nil
end  -- contract_baryon_2pt
